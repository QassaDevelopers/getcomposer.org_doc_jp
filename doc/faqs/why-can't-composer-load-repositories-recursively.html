<!DOCTYPE html>
<html class="no-js" lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Composer</title>
        <meta name="description" content="Dependency Management for PHP">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <link rel="stylesheet" href="/css/styles.min.css">
        <script>
            if (location.host == "192.168.56.21:12345") {
                // It's my local development environment host.
                document.write(
                    '<script src="http://' + 
                    (location.host || 'localhost').split(':')[0] + 
                    ':35729/livereload.js?snipver=1"></' + 
                    'script>'
                )
            }
        </script>
    </head>
    <body>
        <div id="container">
            <header>
            </header>
            <div id="main" role="main">
                <h1 id="why-can-t-composer-load-repositories-recursively-">Why can&#39;t Composer load repositories recursively?</h1>
<p>You may run into problems when using custom repositories because Composer does
not load the repositories of your requirements, so you have to redefine those
repositories in all your <code>composer.json</code> files.</p>
<p>Before going into details as to why this is like that, you have to understand
that the main use of custom VCS &amp; package repositories is to temporarily try
some things, or use a fork of a project until your pull request is merged, etc.
You should not use them to keep track of private packages. For that you should
look into <a href="../articles/handling-private-packages-with-satis.md">setting up Satis</a>
for your company or even for yourself.</p>
<p>There are three ways the dependency solver could work with custom repositories:</p>
<ul>
<li><p>Fetch the repositories of root package, get all the packages from the defined
repositories, resolve requirements. This is the current state and it works well
except for the limitation of not loading repositories recursively.</p>
</li>
<li><p>Fetch the repositories of root package, while initializing packages from the
defined repos, initialize recursively all repos found in those packages, and
their package&#39;s packages, etc, then resolve requirements. It could work, but it
slows down the initialization a lot since VCS repos can each take a few seconds,
and it could end up in a completely broken state since many versions of a package
could define the same packages inside a package repository, but with different
dist/source. There are many many ways this could go wrong.</p>
</li>
<li><p>Fetch the repositories of root package, then fetch the repositories of the
first level dependencies, then fetch the repositories of their dependencies, etc,
then resolve requirements. This sounds more efficient, but it suffers from the
same problems than the second solution, because loading the repositories of the
dependencies is not as easy as it sounds. You need to load all the repos of all
the potential matches for a requirement, which again might have conflicting
package definitions.</p>
</li>
</ul>

                 <p class="fork-and-edit">
                    誤字を見つけましたか？ 何か間違いがありますか？ <a href="http://github.com/composer/composer/">forkして編集してください</a>！
                    <!--
                    Found a typo? Something is wrong in this documentation? Just <a href="http://github.com/composer/composer/edit/master/doc/{{ file }}">fork and edit</a> it!
                    -->
                </p>
            </div>
            <footer>
                <p class="license">Composer and all content on this site are released under the <a href="https://github.com/composer/composer/blob/master/LICENSE">MIT license</a>.</p>
            </footer>
        </div>
    </body>
</html>