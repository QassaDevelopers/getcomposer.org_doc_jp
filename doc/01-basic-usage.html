<!DOCTYPE html>
<html class="no-js" lang="ja">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Composer ドキュメント日本語訳</title>
        <meta name="description" content="PHPの依存管理ツール">
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <link rel="stylesheet" href="/getcomposer.org_doc_jp/css/styles.min.css">
        <link rel="shortcut icon" href="/getcomposer.org_doc_jp/favicon.ico">
        <script src="/getcomposer.org_doc_jp/js/scripts.min.js"></script>
        <script>
            if (location.host.indexOf(":12345") >= 0) {
                // It's my local developing server port.
                document.write(
                    '<script src="http://' + 
                    (location.host || 'localhost').split(':')[0] + 
                    ':35729/livereload.js?snipver=1"></' + 
                    'script>'
                )
            }
        </script>
    </head>
    <body>
        <div id="container">
            <header>
              <a href="http://getcomposer.org/">ホーム</a><a class="" href="/getcomposer.org_doc_jp/doc/00-intro.html">はじめに</a><a class="" href="http://getcomposer.org/download/">ダウンロード</a><a class="" href="/getcomposer.org_doc_jp/doc/">ドキュメント</a><a class="last" href="http://packagist.org/">パッケージの参照</a>
              <div class="note">
                * これはKohki Makimotoが個人的に翻訳している記事です。<a class="repo" href="https://github.com/kohkimakimoto/getcomposer.org_doc_jp">Githubリポジトリはここです。</a>
              </div>
            </header>
            <div id="main" role="main">
                <h1 id="-">基本的な使い方</h1>
<h2 id="-">インストール</h2>
<p>Composerをインストールするために、<code>composer.phar</code>の実行ファイルをダウンロードする必要があります。</p>
<!--
To install Composer, you just need to download the `composer.phar` executable.
-->

<pre><code>$ curl -sS https://getcomposer.org/installer | php</code></pre>
<p>詳細は<a href="00-intro.html">イントロダクション</a>の章を見てください。</p>
<!--
For the details, see the [Introduction](00-intro.md) chapter.
-->

<p>Composerが動作するかチェックするために、<code>php</code>でPHARを実行してください。</p>
<!--
To check if Composer is working, just run the PHAR through `php`:
-->

<pre><code>$ php composer.phar</code></pre>
<p>利用できるコマンドの一覧が表示されるでしょう。</p>
<!--
This should give you a list of available commands.
-->

<blockquote>
<p><strong>注意:</strong> <code>--check</code>オプションを使えばComposerをダウンロードせずに、チェックだけを行うこともできます。
より詳しい情報は<code>--help</code>オプションを使ってみてください。</p>
<pre><code>$ curl -sS https://getcomposer.org/installer | php -- --help</code></pre>
</blockquote>
<!--
> **Note:** You can also perform the checks only without downloading Composer
> by using the `--check` option. For more information, just use `--help`.
>
>     $ curl -sS https://getcomposer.org/installer | php -- --help
-->

<h2 id="-composer-json-"><code>composer.json</code>: プロジェクトのセットアップ</h2>
<p>Composerをあなたのプロジェクトで利用するのに必要となるものは<code>composer.json</code>ファイルだけです。
このファイルにはプロジェクトの依存情報が記述されます。そしてその他のメタデータも含まれるかもしれません。</p>
<!--
To start using Composer in your project, all you need is a `composer.json`
file. This file describes the dependencies of your project and may contain
other metadata as well.
-->

<p><a href="http://json.org/">JSONフォーマット</a>は書くのがとても簡単です。
これはネストした構造を定義することができます。</p>
<!--
The [JSON format](http://json.org/) is quite easy to write. It allows you to
define nested structures.
-->

<h3 id="-require-"><code>require</code>キー</h3>
<p>最初に（そして、しばしばただひとつの）あなたが<code>composer.json</code>で指定するものは、<code>require</code>キーです。
あなたはComposerにプロジェクトが依存しているパッケージがどれであるかを、単に定義するだけです。</p>
<!--
The first (and often only) thing you specify in `composer.json` is the
`require` key. You're simply telling Composer which packages your project
depends on.
-->

<pre><code>{
    &quot;require&quot;: {
        &quot;monolog/monolog&quot;: &quot;1.0.*&quot;
    }
}</code></pre>
<p>見たとおり、<code>require</code>は<strong>パッケージ名</strong> (例:<code>monolog/monolog</code>) と <strong>パッケージバージョン</strong> (例:<code>1.0.*</code>) で指定されたオブジェクトを扱います。</p>
<!--
As you can see, `require` takes an object that maps **package names** (e.g. `monolog/monolog`)
to **package versions** (e.g. `1.0.*`).
-->

<h3 id="-">パッケージ名</h3>
<p>パッケージ名はベンダー名とプロジェクト名から成ります。これらはしばしば同一になります。 - ベンダー名はネーミングが衝突するのを避けるためだけにあります。
異なった二人の人物が<code>json</code>という名前のライブラリ、<code>igorw/json</code>と<code>seldaek/json</code>を作成できます。</p>
<!--
The package name consists of a vendor name and the project's name. Often these
will be identical - the vendor name just exists to prevent naming clashes. It allows
two different people to create a library named `json`, which would then just be
named `igorw/json` and `seldaek/json`.
-->

<p>私たちは<code>monolog/monolog</code>を必要としていますね。ベンダー名はプロジェクト名と同じです。
ベンダー名はプロジェクトにとってユニークな名前であることが推奨されます。
また関連するプロジェクトを同じネームスペース配下に加えることもできます。
もしあなたがライブラリをメンテナンスしているのならば、これを小さいパートに分けることは本当に簡単でしょう。</p>
<!--
Here we are requiring `monolog/monolog`, so the vendor name is the same as the
project's name. For projects with a unique name this is recommended. It also
allows adding more related projects under the same namespace later on. If you
are maintaining a library, this would make it really easy to split it up into
smaller decoupled parts.
-->

<h3 id="-">パッケージバージョン</h3>
<p>前述の例で、私たちはmonologのバージョン<code>1.0.*</code>を必要としていました。
これは<code>1.0</code>の開発ブランチの全てのバージョンのことです。
<code>1.0.0</code>、<code>1.0.2</code>、<code>1.0.20</code>全てに当てはまります。</p>
<!--
In the previous example we were requiring version `1.0.*` of monolog. This
means any version in the `1.0` development branch. It would match `1.0.0`,
`1.0.2` or `1.0.20`.
-->

<p>バージョンの制約はいくつかの方法で指定できます。</p>
<!--
Version constraints can be specified in a few different ways.
-->

<table>
<thead>
<tr>
<th>名称</th>
<th>例</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>特定のバージョン</td>
<td><code>1.0.2</code></td>
<td>パッケージの特定のバージョンを指定できます。</td>
</tr>
<tr>
<td>レンジ</td>
<td><code>&gt;=1.0</code> <code>&gt;=1.0,&lt;2.0</code> <code>&gt;=1.0,<1.1 &#124; >=1.2</code></td>
<td>比較演算子で有効なバージョンの範囲を指定できます。 使用できる演算子は<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code>です。<br />カンマ区切りで<strong>論理積(logical AND)</strong>、パイプ<code>&#124;</code>で<strong>論理和(logical OR)</strong>として扱われる範囲を複数指定できます。<br />ANDはORより優先されます。</td>
</tr>
<tr>
<td>ワイルドカード</td>
<td><code>1.0.*</code></td>
<td>ワイルドカード<code>*</code>でパターン指定をできます。<code>1.0.*</code> は<code>&gt;=1.0,&lt;1.1</code>と同じです。</td>
</tr>
<tr>
<td>チルダ演算子</td>
<td><code>~1.2</code></td>
<td>これはセマンティックバージョニングに従っているプロジェクトにおいてとても便利です。<code>~1.2</code>は<code>&gt;=1.2,&lt;2.0</code>と同じです。詳細は次のセクションを読んでください。</td>
</tr>
</tbody>
</table>
<!--
Name           | Example                                   | Description
-------------- | ---------------------                     | -----------
Exact version  | `1.0.2`                                   | You can specify the exact version of a package.
Range          | `>=1.0` `>=1.0,<2.0` `>=1.0,<1.1 | >=1.2` | By using comparison operators you can specify ranges of valid versions. Valid operators are `>`, `>=`, `<`, `<=`, `!=`. <br />You can define multiple ranges, separated by a comma, which will be treated as a **logical AND**. A pipe symbol `|` will be treated as a **logical OR**. <br />AND has higher precedence than OR.
Wildcard       | `1.0.*`                                   | You can specify a pattern with a `*` wildcard. `1.0.*` is the equivalent of `>=1.0,<1.1`.
Tilde Operator | `~1.2`                                    | Very useful for projects that follow semantic versioning. `~1.2` is equivalent to `>=1.2,<2.0`. For more details, read the next section below.
-->


<h3 id="-">次の重要なリリース (チルダ演算子)</h3>
<p><code>~1.2</code>の例は<code>~</code>演算子の説明としてベストです。これは<code>&gt;=1.2,&lt;2.0</code>と同義です。
一方、<code>~1.2.3</code>は<code>&gt;=1.2.3,&lt;1.3</code>と同義です。
ごらんの通り、これは<a href="http://semver.org/">セマンティックバージョニング</a>に準拠しているプロジェクトにおいてとても便利です。
最も一般的な使い方は、<code>~1.2</code>(2.0は含まず全てのアップロードを許可する)のように、
あなたが依存している最小のマイナーバージョンをマークすることでしょう。
理論上は、2.0までの動作について後方互換性の破壊がなくなるでしょう。
もう一つの使い方は、<code>~</code>を最小のバージョンに指定することです。
これは指定された末尾の数値の更新を許可します。</p>
<!--
The `~` operator is best explained by example: `~1.2` is equivalent to
`>=1.2,<2.0`, while `~1.2.3` is equivalent to `>=1.2.3,<1.3`. As you can see
it is mostly useful for projects respecting [semantic
versioning](http://semver.org/). A common usage would be to mark the minimum
minor version you depend on, like `~1.2` (which allows anything up to, but not
including, 2.0). Since in theory there should be no backwards compatibility
breaks until 2.0, that works well. Another way of looking at it is that using
`~` specifies a minimum version, but allows the last digit specified to go up.
-->

<h3 id="-">安定性</h3>
<p>デフォルトでは安定版のリリースのみが考慮されます。依存物にRC、ベータ、アルファ版、または開発バージョンを扱いたい場合
<a href="04-schema.html#package-links">安定性フラグ</a>を使うことができます。
依存物ごとにそれを設定する代わりに、全てのパッケージを変更するための<a href="04-schema.html#minimum-stability">最小の安定性</a>設定を使うこともできます。</p>
<!--
By default only stable releases are taken into consideration. If you would like
to also get RC, beta, alpha or dev versions of your dependencies you can do
so using [stability flags](04-schema.md#package-links). To change that for all
packages instead of doing per dependency you can also use the
[minimum-stability](04-schema.md#minimum-stability) setting.
-->

<h2 id="-">依存物をインストール</h2>
<p>ローカルのプロジェクトに定義した依存物をフェッチするために、<code>composer.phar</code>の<code>install</code>コマンドを実行します。</p>
<!--
To fetch the defined dependencies into your local project, just run the
`install` command of `composer.phar`.
-->

<pre><code>$ php composer.phar install</code></pre>
<p>これは指定したバージョン制約にマッチする<code>monolog/monolog</code>の最新バージョンを見つけて、<code>vendor</code>ディレクトリ内にダウンロードします。
サードパーティのコードを<code>vendor</code>という名前のディレクトリ内におくことは慣習です。
monologの場合、<code>vendor/monolog/monolog</code>に置かれます。</p>
<!--
This will find the latest version of `monolog/monolog` that matches the
supplied version constraint and download it into the `vendor` directory.
It's a convention to put third party code into a directory named `vendor`.
In case of monolog it will put it into `vendor/monolog/monolog`.
-->

<blockquote>
<p><strong>Tip:</strong> gitをプロジェクトで使っているのなら、多分<code>.gitignore</code>に<code>vendor</code>を追加したいでしょう。
リポジトリにコードを追加したくないので。</p>
</blockquote>
<!--
> **Tip:** If you are using git for your project, you probably want to add
> `vendor` into your `.gitignore`. You really don't want to add all of that
> code to your repository.
-->

<p><code>install</code>コマンドがするもう一つのことは、<code>composer.lock</code>ファイルをプロジェクトルートに追加することです。</p>
<!--
Another thing that the `install` command does is it adds a `composer.lock`
file into your project root.
-->

<h2 id="-composer-lock-"><code>composer.lock</code> - ロックファイル</h2>
<p>依存物をインストールしたあとに、Composerはインストールしたパッケージの実際のバージョンのリストを<code>composer.lock</code>に書き込みます。
このファイルはプロジェクトをこれらの特定バージョンにロックします。</p>
<!--
After installing the dependencies, Composer writes the list of the exact
versions it installed into a `composer.lock` file. This locks the project
to those specific versions.
-->

<p><strong>アプリケーションの <code>composer.lock</code>を(<code>composer.json</code>と一緒に)バージョンコントロールにコミットしてください。 </strong></p>
<!--
**Commit your application's `composer.lock` (along with `composer.json`) into version control.**
-->

<p>これは重要なことです。なぜなら<code>install</code>コマンドはロックファイルが存在するかチェックし、
あるならそこに指定されているバージョンをダウンロードするからです。
(<code>composer.json</code>の内容に関わらず)</p>
<!--
This is important because the `install` command checks if a lock file is present,
and if it is, it downloads the versions specified there (regardless of what `composer.json`
says).
-->

<p>これはプロジェクトをセットアップするのが誰であっても厳密に同じバージョンの依存物をダウンロードする、ということです。
CIサーバ、プロダクションマシン、チーム内の他のデベロッパー、全てで、誰でも同じ依存物を実行します。
これは、開発への潜在的なバグの影響を軽減します。
たとえあなたが一人で開発していたとしても、6ヶ月の間にプロジェクトを再インストールしたとき、
依存物がその後多くの新しいバージョンをリリースしていたとしても、
あなたはインストールされた依存物がちゃんと動くことを確信できます。</p>
<!--
This means that anyone who sets up the project will download the exact
same version of the dependencies. Your CI server, production machines, other
developers in your team, everything and everyone runs on the same dependencies, which
mitigates the potential for bugs affecting only some parts of the deployments. Even if you
develop alone, in six months when reinstalling the project you can feel confident the
dependencies installed are still working even if your dependencies released
many new versions since then.
-->

<p><code>composer.lock</code>ファイルがない場合、Composerは依存物とバージョンを<code>composer.json</code>から読み、
ロックファイルを作成します。</p>
<!--
If no `composer.lock` file exists, Composer will read the dependencies and
versions from `composer.json` and  create the lock file.
-->

<p>これは、依存物に新しいバージョンがあった場合に自動的にはアップデートしないということです。
新しいバージョンにアップデートするためには、<code>update</code>コマンドを使います。
これはマッチする最新のバージョン(<code>composer.json</code>ファイルによります)をフェッチしロックファイルをその新しいバージョンで
アップデートします。</p>
<!--
This means that if any of the dependencies get a new version, you won't get the updates
automatically. To update to the new version, use `update` command. This will fetch
the latest matching versions (according to your `composer.json` file) and also update
the lock file with the new version.
-->

<pre><code>$ php composer.phar update</code></pre>
<p>一つの依存物をインストール、またはアップデートしたいだけなら、ホワイトリストが使えます。</p>
<!--
If you only want to install or update one dependency, you can whitelist them:
-->

<pre><code>$ php composer.phar update monolog/monolog [...]</code></pre>
<blockquote>
<p><strong>注意:</strong> ライブラリの場合はロックファイルのコミットは不必要です。
<a href="02-libraries.html#lock-file">ライブラリ - ロックファイル</a>を参照してください。</p>
</blockquote>
<!--
> **Note:** For libraries it is not necessarily recommended to commit the lock file,
> see also: [Libraries - Lock file](02-libraries.md#lock-file).
-->

<h2 id="packagist">Packagist</h2>
<p><a href="https://packagist.org/">Packagist</a>はメインのComposerリポジトリです。
Composerリポジトリは基本的なパッケージソースになります。
これはパッケージを取得元となる場所のことです。
Packagistは全ての人が利用できる中央リポジトリであることを目的としています。
この場所で利用できるパッケージは自動的に<code>require</code>できるということです。</p>
<!--
[Packagist](https://packagist.org/) is the main Composer repository. A Composer
repository is basically a package source: a place where you can get packages
from. Packagist aims to be the central repository that everybody uses. This
means that you can automatically `require` any package that is available
there.
-->

<p><a href="https://packagist.org/">packagistのWebサイト</a> (packagist.org)ではパッケージを参照、検索できます。</p>
<!--
If you go to the [packagist website](https://packagist.org/) (packagist.org),
you can browse and search for packages.
-->

<p>Composerを使っているオープンソースプロジェクトはそのパッケージをpackagist上で公開するべきです。
Composerを使うために、ライブラリをpackagistに載せる必要ありません。
しかしそうすることで人生がかなりシンプルになります。</p>
<!--
Any open source project using Composer should publish their packages on
packagist. A library doesn't need to be on packagist to be used by Composer,
but it makes life quite a bit simpler.
-->

<h2 id="-">オートローディング</h2>
<p>オートロード情報を指定するライブラリのためにComposerは<code>vendor/autoload.php</code>ファイルを生成します。
単にこのファイルをインクルードすれば、オートローディングを自由に手に入れることができます。</p>
<!--
For libraries that specify autoload information, Composer generates a
`vendor/autoload.php` file. You can simply include this file and you
will get autoloading for free.
-->

<pre><code>require &#39;vendor/autoload.php&#39;;</code></pre>
<p>これはサードパーティコードの利用を本当に簡単にします。例：プロジェクトがmonologに依存している場合、
単にクラスをこのように始めればいいだけなのです。これでオートロードが行われます。</p>
<!--
This makes it really easy to use third party code. For example: If your
project depends on monolog, you can just start using classes from it, and they
will be autoloaded.
-->

<pre><code>$log = new Monolog\Logger(&#39;name&#39;);
$log-&gt;pushHandler(new Monolog\Handler\StreamHandler(&#39;app.log&#39;, Monolog\Logger::WARNING));

$log-&gt;addWarning(&#39;Foo&#39;);</code></pre>
<p><code>composer.json</code>に<code>autoload</code>フィールドを追加すれば、自分のコードでさえオートローダに追加することができます。</p>
<!--
You can even add your own code to the autoloader by adding an `autoload` field
to `composer.json`.
-->

<pre><code>{
    &quot;autoload&quot;: {
        &quot;psr-0&quot;: {&quot;Acme\\&quot;: &quot;src/&quot;}
    }
}</code></pre>
<p>Composerは<a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a>オートローダを<code>Acme</code>ネームスペースに登録します。</p>
<!--
Composer will register a
[PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md)
autoloader for the `Acme` namespace.
-->

<p>ネームスペースからディレクトリへのマッピングを定義しています。
<code>src</code>ディレクトリはプロジェクトルートにあるとします。同じ階層に<code>vendor</code>もあります。
例えば、ファイル名が<code>src/Acme/Foo.php</code>は<code>Acme\Foo</code>クラスを含みます。</p>
<!--
You define a mapping from namespaces to directories. The `src` directory would
be in your project root, on the same level as `vendor` directory is. An example
filename would be `src/Acme/Foo.php` containing an `Acme\Foo` class.
-->

<p><code>autoload</code>フィールドを追加したあと、<code>vendor/autoload.php</code>を再生成するため<code>install</code>を再実行しなければなりません。</p>
<!--
After adding the `autoload` field, you have to re-run `install` to re-generate
the `vendor/autoload.php` file.
-->

<p>オートロードファイルのインクルードはまた、autoloaderインスタンスを戻します。
なのでインクルード呼び出しの戻り値を変数に保持しておくことができます。
そして、ネームスペースを追加することができます。
これはテストスイート内で便利です。例えば、</p>
<!--
Including that file will also return the autoloader instance, so you can store
the return value of the include call in a variable and add more namespaces.
This can be useful for autoloading classes in a test suite, for example.
-->

<pre><code>$loader = require &#39;vendor/autoload.php&#39;;
$loader-&gt;add(&#39;Acme\\Test\\&#39;, __DIR__);</code></pre>
<p>PSR-0オートローディングに加えて、クラスマップもまたサポートしています。
これはPSR-0に準拠していなくてもクラスをオートロードすることができます。
詳細は<a href="04-schema.html#autoload">オートロードリファレンス</a>を参照してください。</p>
<!--
In addition to PSR-0 autoloading, classmap is also supported. This allows
classes to be autoloaded even if they do not conform to PSR-0. See the
[autoload reference](04-schema.md#autoload) for more details.
-->

<blockquote>
<p><strong>注意:</strong> Composerは自前のオートローダを提供しています. もしそれを使いたくない場合は
単に<code>vendor/composer/autoload_namespaces.php</code>をインクルードすることができます。
これはネームスペースとディレクトリをマッピングしている連想配列を戻します。</p>
</blockquote>
<!--
> **Note:** Composer provides its own autoloader. If you don't want to use
that one, you can just include `vendor/composer/autoload_namespaces.php`,
which returns an associative array mapping namespaces to directories.
-->

<p class="prev-next">
  &larr; <a href="00-intro.html">イントロダクション</a>  |  <a href="02-libraries.html">ライブラリ</a> &rarr;
</p>

<!--
&larr; [Intro](00-intro.md)  |  [Libraries](02-libraries.md) &rarr;
-->

                 <p class="fork-and-edit">
                    誤字を見つけましたか？ 何か間違いがありますか？ <a href="https://github.com/kohkimakimoto/getcomposer.org_doc_jp">forkして編集してください</a>！
                    <!--
                    Found a typo? Something is wrong in this documentation? Just <a href="http://github.com/composer/composer/edit/master/doc/{{ file }}">fork and edit</a> it!
                    -->
                </p>
            </div>
            <footer>
                <p class="license">Composer and all content on this site are released under the <a href="https://github.com/composer/composer/blob/master/LICENSE">MIT license</a>.</p>
            </footer>
        </div>
    </body>
</html>